#!/usr/bin/python
import sys, os, threading, traceback
from select import select
from evdev import ecodes, InputDevice, list_devices
from evdev.events import KeyEvent
from hosted import node, config, device as ibdevice

config.restart_on_update()

screen_w, screen_h = ibdevice.screen_resolution

devices = {}
def update_devices():
    new = set(list_devices("/dev/input/"))
    old = set(devices.keys())

    for device_name in new - old:
        device = InputDevice(device_name)
        devices[device_name] = device
        import pprint
        pprint.pprint(device.capabilities(verbose=True))
        pprint.pprint(device.capabilities(verbose=False))
        sys.stdout.flush()

    for device_name in old - new:
        del devices[device_name]

touch_state = dict(
    down = False,
    x = 0,
    y = 0,
)

def scale(value, abs_info, screen):
    if abs_info is None:
        return value
    vmin = abs_info.min
    vmax = abs_info.max
    value_range = vmax - vmin
    return int(float(screen) / value_range * (value - vmin))

def device_event(device, event):
    if event.type == ecodes.EV_KEY and event.code in (ecodes.BTN_TOUCH, ecodes.BTN_MOUSE, ecodes.BTN_LEFT):
        touch_state['down'] = event.value != 0
    if event.type == ecodes.EV_ABS:
        info = device.capabilities(verbose=False)
        abs_infos = dict(info[ecodes.EV_ABS])
        if event.code == ecodes.ABS_X:
            touch_state['x'] = scale(
                event.value, abs_infos.get(ecodes.ABS_X), screen_w
            )
        if event.code == ecodes.ABS_Y:
            touch_state['y'] = scale(
                event.value, abs_infos.get(ecodes.ABS_Y), screen_h
            )
    if event.type == ecodes.EV_KEY and event.code in ecodes.KEY:
        node['/event/keyboard'](dict(
            key = ecodes.KEY[event.code].replace("KEY_", "").lower(),
            action = {
                KeyEvent.key_up: "up",
                KeyEvent.key_down: "down",
                KeyEvent.key_hold: "hold",
            }[event.value],
        ))

def monitor_touch():
    while 1:
        update_devices()
        r, w, e = select(devices.values(), [], [], 5)
        for device in r:
            try:
                for ev in device.read():
                    device_event(device, ev)
            except IOError:
                # device disconnected
                pass
        node['/event/touch'](touch_state)

def monitor_gpio():
    pins = set()
    for page in config.pages:
        for link in page['links']:
            if link['type'] == 'gpio':
                pins.add(link['options']['pin'])
    print >>sys.stderr, "gpios active: %s" % (pins,)
    for pin in pins:
        ibdevice.gpio.monitor(pin)
    for pin, high in ibdevice.gpio.poll_forever():
        node['/event/gpio'](dict(
            pin = pin,
            high = high,
        ))

def run_in_thread(fn):
    def wrap():
        try:
            while 1:
                fn()
        except Exception:
            traceback.print_exc()
            os._exit(1)
    thread = threading.Thread(target=wrap)
    thread.daemon = True
    thread.start()

if __name__ == "__main__":
    run_in_thread(monitor_touch)
    monitor_gpio()
